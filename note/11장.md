# 코루틴과 동시성 프로그래밍

## 동시성 프로그래밍

- 동기적(Synchronous) 수행
    - 순서대로 작업을 수행하여 하나의 루틴을 완료한 후 다른 루틴을 실행하는 방식
    - 다양한 기능이 한꺼번에 일어나는 다중 실행 환경에서는 성능상의 제약 발생
        - UI, 데이터 다운로드를 동시에 대응해야 하는 경우
- 비동기적(Asynchronous) 수행
    - 다양한 기능을 동시에 수행할 수 있는 방식
    - 전통적인 스레드를 이용하거나 RxJava, Reactive 와 같은 서드파티 라이브러리에서 제공
    - Kotlin 에서는 Coroutines 를 기본으로 제공

- Coroutines
    - 먼저 하나의 개별적인 작업을 루틴(routine)이라고 부르는데 여러 개의 루틴들이 협력(co)한다는 의미로 만들어진 합성어
    - Kotlin 의 Coroutines 를 사용하면 Non-blocking 또는 비동기 코드를 마치 일반적인 동기 코드처럼 쉽게 작성하면서도 비동기 효과를 낼 수 있음

### 동시성 프로그래밍 용어 정리

- Blocking 동작

![Blocking Sequence Diagram](img/blocking_sequence_diagram.png)

- Non-blocking 동작

![Non-Blocking Sequence Diagram](img/non_blocking_sequence_diagram.png)

### 프로세스와 스레드

- Task 개념
    - 보통 Task 는 큰 실행 단위인 프로세스나 좀 더 작은 실행 단위인 스레드로 생각할 수 있음
    - 프로세스는 실행되는 메모리, 스택, 열린 파일 등을 모두 포함하기 때문에 프로세스간 문맥 교환(context-switching)을 하는데 비용이 큼
    - 스레드는 자신의 스택만 독립적으로 가지고 나머지는 대부분 공유하므로 문맥 교환 비용이 낮아 프로그래밍에서 많이 사용
    - 다만 여러 개의 스레드를 구성하면 코드가 복잡

### 문맥교환(Context-Switching)

- 하나의 프로세스나 스레드가 CPU 를 사용하고 있는 상태에서 다른 프로세스나 스레드가 CPU 를 사용하도록 하기 위해, 이전의 프로세스의 상태(문맥)를 보관화고 새로운 프로세스의 상태를 적재하는 과정

![Context Switching](img/context_switching.png)

- 기본 Thread 생성해 보기

```kotlin
class SimpleThread : Thread() {
    override fun run() {
        println("Current Thread: ${currentThread()}")
    }
}

class SimpleRunnable : Runnable {
    override fun run() {
        println("Current ThreaD: ${Thread.currentThread()}")
    }
}

fun main() {
    val thread = SimpleThread()
    thread.start()

    val runnable = SimpleRunnable()
    val thread1 = Thread(runnable)
    thread1.start()
}
```

### Thread 의 생성

- 익명 객체를 사용하면 클래스의 객체를 만들지 않고도 다음과 같이 실행

```kotlin
object : Thread() {
    override fun run() {
        println("Current Thread(object): ${currentThread()}")
    }
}
```

- Thread Class 를 손쉽게 사용하도록 함수 만들기

```kotlin
public fun thread(
    start: Boolean = true,
    isDaemon: Boolean = false,
    contextClassLoader: ClassLoader? = null,
    name: String? = null,
    priority: Int = -1,
    block: () -> Unit
): Thread {
    val thread = object : Thread() {
        override fun run() {
            block()
        }
    }
    if (isDaemon) {
        thread.isDaemon = true
    }
    if (priority > 0) {
        thread.priority = priority
    }
    if (name != null) {
        thread.name = name
    }
    if (contextClassLoader != null) {
        thread.contextClassLoader = contextClassLoader
    }
    if (start) {
        thread.start()
    }
    return thread
}

fun main() {
    thread(start = true) {
        println("Current Thread(Custom function): ${Thread.currentThread()}")
        println("Priority: ${Thread.currentThread().priority}")
        println("Name: ${Thread.currentThread().name}")
        println("IsDaemon: ${Thread.currentThread().isDaemon}")
    }
}
```

### Thread Pool 사용하기

- `newFixedThreadPool()`
    - 자주 재사용되는 스레드를 이용하기 위해 미리 생성된 스레드풀에서 스레드 이용

```kotlin
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

val myService: ExecutorService = Executors.newFixedThreadPool(8)
var i = 0

while (i < items.size) {
    val item = items[i]
    myService.submit {
        processItem(item)
    }
    i++
}
```

## Coroutines 개념과 사용

### Kotlin 의 Coroutines

- 스레드와 달리 Kotlin 은 Coroutines 을 통해 복잡성을 줄이고도 손쉽게 일시 중단하거나 다시 시작하는 루틴을 만들어낼 수 있음
- 멀티테스킹을 실현하면서 가벼운 스레드라고도 불림
- Coroutines 는 문맥교환 없이 해당 routine 을 일시중단을 통해 제어

### Coroutines 의 주요 패키지

- `kotlinx.coroutines`의 common 패키지
    - `launch`, `async`: Coroutines Builder
    - `Job`, `Deferred`: cancellation 지원을 위한 기능
    - `Dispatchers`: Default 는 백그라운드 Coroutines 를 위함, Main 은 Android, Swing, JavaFx 를 위해 사용
    - `delay`, `yield`: 상위 레벨 지연 함수
    - `Channel`, `Mutex`: 통신과 동기화를 위한 기능
    - `coroutineScope`, `supervisorScope`: 범위 빌더
    - `select`: 표현식 지원

- core 패키지
    - `CommonPool`: Coroutines Context
    - `produce`, `actor`: Coroutines Builder

### Coroutines Builder

- `launch`
    - 일단 실행하고 잊어버리는(fire-and-forget) 형태의 Coroutines 로 메인 프로그램과 독립되어 실행 가능
    - 기본적으로 즉시 실행하며 블록 내의 실행 결과는 반환하지 않음
    - 상위 코드를 블록시키지 않고(Non-blocking) 관리를 위한 Job 객체를 즉시 반환
    - `join`을 통해 상위 코드가 종료되지 않고 완료를 기다리게 할 수 있음

- `async`
    - 비동기 호출을 위해 만든 Coroutines 로 결과나 예외를 반환
    - 실행 결과는 `Deffered<T>`를 통해 반환하며 `await`을 통해 받을 수 있음
    - `await`는 작업이 완료될 때까지 기다림

### `launch`와 `async`

- 기본적인 launch Builder 의 사용

```kotlin
import kotlinx.coroutines.GlobalScope

fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    println("Hello, ")
    Thread.sleep(2000L)
}
```

- 일시 중단(suspended) 함수
    - `delay()`의 경우 일시 중단될 수 있으며 필요한 경우 재개(resume)

- `delay()`의 선언부
    - `suspend` 함수를 Coroutines 블록 외에 사용하면 오류 발생

```kotlin
public suspend fun delay(timeMillis: kotlin.Long): kotlin.Unit { /* compiled code */
}
```

- 사용자 함수에 `suspend` 적용
    - 컴파일러는 `suspend`가 붙은 함수를 자동적으로 추출해 Continuation Class 로부터 분리된 루틴을 만듬
    - 이러한 함수를 사용하기 위해 Coroutines Builder 인 `launch`와 `async`에서 이용할 수 있음

```kotlin
suspend fun doSomething() {
    println("Do Something!")
}
```

