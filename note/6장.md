# 프로퍼티와 초기화

> 프로퍼티에 접근하려면 접근 메소드를 통해야 해요!

## 프로퍼티의 접근

- Java 의 Fields
    - 단순한 변수 선언만 가지기 때문에 접근을 위한 메소드를 따로 만들어야 함

- Kotlin 의 Property
    - 변수 선언과 기본적인 접근 메소드를 모두 가지고 있음
    - 따로 접근 메소드를 만들지 않아도 내부적으로 생성하게 됨

### Java 에서 Field 를 사용할 때

- Getter 와 Setter 의 구성
    - Getter 와 Setter 를 합쳐 접근 메소드(Access Methods)라고함
    - Java 에서는 모든 필드에 대한 접근 메소드를 만들어야 하는 수고를 해야함

- Java 의 Person Class 와 접근 메소드

```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

### Kotlin 에서 Getter 와 Setter 가 작동하는 방식

- 접근 메소드는 생략 (내부적으로 생성됨)

```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
    var name: String = _name
    var age: Int = _age
}
```

```kotlin
class User(val id: Int, var name: String, var age: Int)
```

- Getter 와 Setter 의 동작

```kotlin
class User(val id: Int, var name: String, var age: Int)

fun main() {
    val user = User(1, "Jason", 30)

    // Getter
    val name = user.name // -> String name = user.getName();

    // Setter
    user.age = 41 // user.setAge(41);

    println("name: $name, ${user.age}")
}
```

#### 기본 Getter 와 Setter 직접 지정

- Getter 와 Setter 가 포함되는 Property 선언 구조

```text
var 프로퍼티이름[: 프로퍼티자료형] [= 프로퍼티초기화]
    [get() { ... }]
    [set(value) { ... }]
    
val 프로퍼티이름[: 프로퍼티자료형] [= 프로퍼티초기화]
    [get() { ... }]
```

- 불변형인 val 는 Getter 만 설정 가능

- 기본 Getter 와 Setter 지정

```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
        get() = field // id 값을 가르키는 일종의 Pointer

    var name: String = _name
        get() = field
        set(value) {
            field = value
        }

    var age: Int = _age
        get() = field
        set(value) {
            field = value
        }
}

fun main() {
    val user = User(1, "GilDong", 30)
    user.age = 35
    println("user.age = ${user.age}")
}
```

### Getter, Setter 에서 사용하는 특수 변수

- `value`: setter 의 매개변수로 외부로부터 값을 가져옴
    - 외부의 값을 받을 변수가 되무로 `value` 대신에 어떤 이름이든지 상관 없음
- `field`: Property 를 참조하는 변수로 보조 필드(backing field) 로 불림
    - Property 를 대신할 임시 필드로 만일 Property 를 직접 사용하면 Getter 나 Setter 가 무한 호출되는 재귀에 빠짐 -> StackOverFlow 발생

- Custom Getter 와 Setter 사용하기

```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
    var name: String = _name
        set(value) {
            println("The name was changed.")
            field = value.toUpperCase()
        }

    var age: Int = _age
}

fun main() {
    val user = User(1, "GilDong", 35)
    user.name = "coco"
    println("user.name = ${user.name}")
}
```

- 임시적인 보조 Property

```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
    private var tempName: String? = null
    var name: String = _name
        get() {
            if (tempName == null) tempName = "NONAME"
            return tempName ?: throw AssertionError("Asserted by others")
        }
    var age: Int = _age
}

fun main() {
    val user = User(1, "GilDong", 35)
    user.name = ""
    println("user.name = ${user.name}")
}
```

- Property Overriding 사용하기

```kotlin
open class First {
    open val x: Int = 0
        get() {
            println("First x")
            return field
        }
    val y: Int = 0
}

class Second : First() {
    override val x: Int = 0
        get() {
            println("Second x")
            return field + 3
        }
//    override val y: Int = 0
}

fun main() {
    val second = Second()
    println(second.x)
    println(second.y)
}
```

## 지연초기화와 위임

### 지연 초기화가 필요한 이유

- 변수나 객체의 값은 생성시 초기화 필요
    - 클래스에서는 기본적으로 선언하는 Property 자료형들은 null 을 가질 수 없음
    - 하지만, 객체의 정보가 나중에 나타나는 경우 나중에 초기화 할 수 있는 방법 필요
    - 지연 초기화를 위해 `lateinit` 과 `lazy` 키워드 사용

### `lateinit` 을 사용한 지연 초기화

- 의존성이 있는 초기화나 unit 테스트를 위한 코드를 작성 시
    - Car Class 의 초기화 부분에 Engine Class 와 의존성을 가지는 경우, Engine 객체가 생성되지 않으면 완전하게 초기화 할 수 없는 경우
    - Unit 테스트를 위해 임시적으로 객체를 생성 시켜야 하는 경우

- Property 지연 초기화
    - Class 를 선언 할 때 Property 선언은 null 을 허용하지 않음
    - 하지만, 지연 초기화를 위한 `lateinit` 키워드를 사용하면 Property 에 값이 바로 할당되지 않아도 됨

- `lateinit` 의 제한
    - `var` 로 선언된 Property 만 가능
    - Property 에 대한 Getter, Setter 를 사용할 수 없음

- `lateinit` 을 이용해 지연 초기화하기

```kotlin
class Person {
    lateinit var name: String

    fun test() {
        if (!::name.isInitialized) {
            println("not initialized")
        } else {
            println("initialized")
        }
    }
}

fun main() {
    val gildong = Person()
    gildong.test()
    gildong.name = "GilDong"
    gildong.test()
    println("name = ${gildong.name}")
}
```

### 객체 지연 초기화

- 객체 생성 시 `lateinit` 을 통한 지연 초기화 가능

```kotlin
data class Person(var name: String, var age: Int)

lateinit var person: Person

fun main() {
    person = Person("GilDong", 30)
    println("${person.name} is ${person.age}")
}
```

### `lazy` 를 사용한 지연 초기화

- `lazy` 를 통한 지연 초기화 특징
    - 호출 시점에 `by lazy { ... }` 정의에 의해 블록 부분의 초기화를 진행
    - 불변의 변수 선언인 `val` 에서만 사용 가능 (Read Only)
    - `val` 이므로 값 변경 불가능

- `by lazy` 로 선언된 Property 지연 초기화 하기

```kotlin
class LazyTest {
    init {
        println("init block")
    }

    val subject by lazy {
        println("lazy initialized")
        "Kotlin Programming"
    }

    fun flow() {
        println("not initialized")
        println("subject one: $subject")
        println("subject two: $subject")
    }
}

fun main() {
    val test = LazyTest()
    test.flow()
}
```

- `by lazy` 로 선언된 객체 지연 초기화

```kotlin
class Person(val name: String, val age: Int)

fun main() {
    var isPersonInstantiated: Boolean = false

    val person: Person by lazy {
        isPersonInstantiated = true
        Person("Kim", 23)
    }
    val personDelegate = lazy { Person("Hong", 40) } // 위임 변수를 사용한 초기화

    println("person Init : $isPersonInstantiated")
    println("personDelegate Init: ${personDelegate.isInitialized()}")

    println("person.name = ${person.name}") // person 초기화
    println("personDelegate.value.name = ${personDelegate.value.name}") // personDelegate 초기화

    println("person Init: $isPersonInstantiated")
    println("personDelegate Init: ${personDelegate.isInitialized()}")
}
```

### `by lazy` 의 모드

- 3가지 모드 지정 가능
    - `SYNCHRONIZED`: 락을 사용해 단일 스레드만이 사용하는 것을 보장(Default)
    - `PUBLICATION`: 여러 군데에서 호출될 수 있으나 처음 초기화된 후 반환 값을 사용
    - `NONE`: 락을 사용하지 않기 때문에 빠르지만 다중 스레드가 접근할 수 있음(값의 일관성을 보장할 수 없음)

```kotlin
private val model by lazy(mode = LazyThreadSafetyMode.NONE) {
    Injector.app().transactionsModel() // 단일 스레드의 사용이 보장될 때
}
```

### `by` 를 이용한 위임

- 위임(Delegation)
    - 하나의 Class 가 다른 Class 에 위임하도록 선언
    - 위임된 Class 가 가지는 멤버를 참조없이 호출

```text
<var | var | class> Property 혹은 Class 이름: 자료형 by 위임자
```

### Class 의 위임

- 다른 Class 의 멤버를 사용하도록 위임

```kotlin
interface Animal {
    fun eat() {}
}

class Cat : Animal {}

val cat = Cat()

class Robot : Animal by cat // Animal 의 정의된 Cat 의 모든 멤버를 Robot 에 위임함
```

- `cat` 은 `Animal` 자료형의 `private` 멤버로 `Robot` Class 내에 저장
- `Cat` 에서 구현된 모든 `Animal` 의 메소드는 정적 메소드로 생성
- 따라서, `Animal` 에 대한 명시적인 참조를 사용하지 않고도 `eat()` 을 바로 호출

### 위임을 사용하는 이유

- Kotlin 의 기본 라이브러리는 `open` 되지 않은 최종 클래스
    - 표준 라이브러리의 무분별한 상속의 복잡한 문제들을 방지
    - 단, 상속이나 직접 클래스의 기능 확장을 하기 어려움
- 위임을 통해 상속과 비슷하게 최종 클래스의 모든 기능을 사용하면서 동시에 기능을 추가 확장 구현할 수 있음

- Class 의 위임 사용하기

```kotlin
interface Car {
    fun go(): String
}

class VanImpl(val power: String) : Car {
    override fun go() = "는 짐을 적재하며 $power 마력을 가집니다."
}

class SportImpl(val power: String) : Car {
    override fun go() = "는 경주용에 사용되며 $power 마력을 가집니다."
}

class CarModel(val model: String, impl: Car) : Car by impl {
    fun carInfo() {
        println("$model ${go()}") // 참조 없이 각 인터페이스 구현 클래스의 go() 접근
    }
}

fun main() {
    val myDamas = CarModel("Damas 2010", VanImpl("100마력"))
    val my350z = CarModel("350Z 2008", SportImpl("350마력"))

    myDamas.carInfo()
    my350z.carInfo()
}
```

### Property 위임과 `by lazy` 다시 보기

- `by lazy { ... }` 도 위임
    - 사용된 Property 는 람다식 함수에 전달되어(위임되어) 함수에 의해 사용

- 동작 분석
    1. `lazy` 람다식 함수는 람다를 전달받아 저장한 `Lazy<T>` 인스턴스를 반환
    2. 최초 Property 의 Getter 실행은 `lazy` 에 넘겨진 람다식 함수를 실행하고 결과를 기록
    3. 이후 Property 의 Getter 실행은 이미 초기화되어 기록된 값을 반환

### `observable` 과 `vetoable` 의 위임

- `observable`
    - Property 를 감시하고 있다가 특정 코드의 로직에서 변경이 일어날 떄 호출
- `vetoable`
    - 감시보다는 수여한다는 의미로 반환값에 따라 Property 변경을 허용하거나 취소

- `observable` 의 간단한 사용의 예

```kotlin
import kotlin.properties.Delegates

class User {
    var name: String by Delegates.observable("NONAME") { property, oldValue, newValue ->
        println("$oldValue -> $newValue")
    }
}

fun main() {
    val user = User()
    user.name = "GilDong"
    user.name = "Dooly"
}
```

- `vetoable` 을 사용한 최대값

```kotlin
import kotlin.properties.Delegates

fun main() {
    var max: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
        newValue > oldValue
    }

    println(max)
    max = 10
    println(max)

    max = 5 // oldValue 인 10 보다 작기 때문에 5 할당 X
    println(max)
}
```