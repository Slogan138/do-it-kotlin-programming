# 프로퍼티와 초기화

> 프로퍼티에 접근하려면 접근 메소드를 통해야 해요!

## 프로퍼티의 접근

- Java 의 Fields
    - 단순한 변수 선언만 가지기 때문에 접근을 위한 메소드를 따로 만들어야 함

- Kotlin 의 Property
    - 변수 선언과 기본적인 접근 메소드를 모두 가지고 있음
    - 따로 접근 메소드를 만들지 않아도 내부적으로 생성하게 됨

### Java 에서 Field 를 사용할 때

- Getter 와 Setter 의 구성
    - Getter 와 Setter 를 합쳐 접근 메소드(Access Methods)라고함
    - Java 에서는 모든 필드에 대한 접근 메소드를 만들어야 하는 수고를 해야함

- Java 의 Person Class 와 접근 메소드

```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

### Kotlin 에서 Getter 와 Setter 가 작동하는 방식

- 접근 메소드는 생략 (내부적으로 생성됨)

```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
    var name: String = _name
    var age: Int = _age
}
```

```kotlin
class User(val id: Int, var name: String, var age: Int)
```

- Getter 와 Setter 의 동작

```kotlin
class User(val id: Int, var name: String, var age: Int)

fun main() {
    val user = User(1, "Jason", 30)

    // Getter
    val name = user.name // -> String name = user.getName();

    // Setter
    user.age = 41 // user.setAge(41);

    println("name: $name, ${user.age}")
}
```

#### 기본 Getter 와 Setter 직접 지정

- Getter 와 Setter 가 포함되는 Property 선언 구조

```text
var 프로퍼티이름[: 프로퍼티자료형] [= 프로퍼티초기화]
    [get() { ... }]
    [set(value) { ... }]
    
val 프로퍼티이름[: 프로퍼티자료형] [= 프로퍼티초기화]
    [get() { ... }]
```

- 불변형인 val 는 Getter 만 설정 가능

- 기본 Getter 와 Setter 지정

```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
        get() = field // id 값을 가르키는 일종의 Pointer

    var name: String = _name
        get() = field
        set(value) {
            field = value
        }

    var age: Int = _age
        get() = field
        set(value) {
            field = value
        }
}

fun main() {
    val user = User(1, "GilDong", 30)
    user.age = 35
    println("user.age = ${user.age}")
}
```

### Getter, Setter 에서 사용하는 특수 변수

- `value`: setter 의 매개변수로 외부로부터 값을 가져옴
    - 외부의 값을 받을 변수가 되무로 `value` 대신에 어떤 이름이든지 상관 없음
- `field`: Property 를 참조하는 변수로 보조 필드(backing field) 로 불림
    - Property 를 대신할 임시 필드로 만일 Property 를 직접 사용하면 Getter 나 Setter 가 무한 호출되는 재귀에 빠짐 -> StackOverFlow 발생

- Custom Getter 와 Setter 사용하기

```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
    var name: String = _name
        set(value) {
            println("The name was changed.")
            field = value.toUpperCase()
        }

    var age: Int = _age
}

fun main() {
    val user = User(1, "GilDong", 35)
    user.name = "coco"
    println("user.name = ${user.name}")
}
```

- 임시적인 보조 Property

```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
    private var tempName: String? = null
    var name: String = _name
        get() {
            if (tempName == null) tempName = "NONAME"
            return tempName ?: throw AssertionError("Asserted by others")
        }
    var age: Int = _age
}

fun main() {
    val user = User(1, "GilDong", 35)
    user.name = ""
    println("user.name = ${user.name}")
}
```

- Property Overriding 사용하기

```kotlin
open class First {
    open val x: Int = 0
        get() {
            println("First x")
            return field
        }
    val y: Int = 0
}

class Second : First() {
    override val x: Int = 0
        get() {
            println("Second x")
            return field + 3
        }
//    override val y: Int = 0
}

fun main() {
    val second = Second()
    println(second.x)
    println(second.y)
}
```